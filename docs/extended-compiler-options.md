---
title: Extended Compiler Options
---

**Note**: this section is only for people who want roll their own build system instead of using the recommended build system, `bsb`. This also provides some tips for contributors who want to debug the compiler.

BuckleScript inherits the command line arguments of the [OCaml compiler](http://caml.inria.fr/pub/docs/manual-ocaml/comp.html). It also adds several BS-specific flags. Run `bsc -help` to see the list.

All the compiler flags can be passed into the `bsc-flags` section of `bsb` (although it does not make sense for some of them to be passed in).

**Note**: this section is not kept very up-to-date. Contributions welcome!

## -bs-main (single directory build)

```sh
bsc -bs-main Main
```

The above tells `bsc` to build the module `Main` and all of its dependencies. When it finishes, it will run `node main.js`.

```sh
bsc -c -bs-main Main
```

Same as above, but it will not run `node`.

## -bs-files

```sh
bsc -c -bs-files *.ml *.mli
```

The above option is available so that you can send a batch of files to the compiler. The compiler will sort the order of the input files before starting compilation.

BuckleScript supports two compilation modes: script mode and package mode. In package mode, you have to provide `package.json` on top and set the options `-bs-package-name`, `-bs-package-output`. In script mode, such flags are not needed.

## -bs-package-name

Use this option followed by the name of your project. It is recommended to use the same `name` as the one in `package.json`.

## -bs-packge-output

This option allows you to configure the output path for a specific module system. The format is `module_system:output/path/relative/to/package.json`.

Currently supported module systems are: CommonJS, AMD and ES6.

For example, when you want to use the ES6 module system, use the `es6` flag:

```sh
bsc -bs-package-name your_package -bs-package-output es6:lib/es6 -c xx.ml
```

**Note**: you can supply multiple `-bs-package-output` flags at once. For example:

```sh
bsc -bs-package-name name -bs-package-output commonjs:lib/js  -bs-package-output amdjs:lib/amdjs -c x.ml
```

The above will generate `x.js` in `lib/js` as a CommonJS module and `lib/amdjs` as an AMD module at the same time.

You would then need a bundler for the different module systems: webpack supports CommonJS and AMD, rollup supports ES6, while google closure compiler supports all three.

## -bs-no-warn-ffi-type

Turn off warnings on FFI type declarations.

## -bs-eval

Example:

```sh
> bsc -dparsetree -drawlambda -bs-eval 'Js.log "hello"'

[
  structure_item (//toplevel//[1,0+0]..[1,0+14])
    Pstr_eval
    expression (//toplevel//[1,0+0]..[1,0+14])
      Pexp_apply
      expression (//toplevel//[1,0+0]..[1,0+6])
        Pexp_ident "Js.log" (//toplevel//[1,0+0]..[1,0+6])
      [
        <label> ""
          expression (//toplevel//[1,0+7]..[1,0+14])
            Pexp_constant Const_string("hello",None)
      ]
]

(setglobal Bs_internal_eval! (seq (log "hello") (makeblock 0)))
// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';


console.log("hello");

/*  Not a pure module */
```

In conjunction with `-bs-eval`: the first block is the output of `-dparsetree`, the second is from `-drawlambda`.

`-bs-eval` does not create intermediate files. It is useful for learning and/or troubleshooting.

## -bs-no-builtin-ppx-ml, -bs-no-builtin-ppx-mli

If you do not use any BS-specific annotations, you can explicitly turn them off. Another use-case is to use `-ppx` explicitly as below:

```sh
bsc -c -ppx bsppx.exe -bs-no-builtin-ppx-ml c.ml
```

## -bs-no-version-header

Do not print the BS version at the beginning of each JS file.

## -bs-g (Experimental, since @3.1.0)

See [Better Data Structures Printing (Debug Mode)](./better-data-structures-printing-debug-mode.md).
